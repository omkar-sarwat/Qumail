[
  {
    "projectId": "09b75804-f482-46fe-a5ed-99058e1cf33c",
    "testId": "2e32068e-432e-443a-8f23-48e0ad5c17b7",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC001-test_root_endpoint_service_metadata",
    "description": "Verify that the root endpoint '/' returns service metadata with HTTP 200 status and correct response schema.",
    "code": "import requests\n\ndef test_root_endpoint_service_metadata():\n    base_url = \"http://localhost:9010\"\n    try:\n        response = requests.get(f\"{base_url}/\", timeout=30)\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request to root endpoint failed: {e}\"\n    assert response.status_code == 200, f\"Expected HTTP 200 but got {response.status_code}\"\n    try:\n        # The root endpoint should return service metadata as JSON\n        json_data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n    # Validate that essential metadata fields are present and correct\n    assert isinstance(json_data, dict), \"Response JSON is not an object\"\n    meta = json_data.get(\"meta\")\n    assert isinstance(meta, dict), \"'meta' field missing or not an object in response\"\n    assert meta.get(\"project\") == \"QuMail-KMS\", \"Unexpected project name in meta\"\n    assert \"date\" in meta and isinstance(meta[\"date\"], str), \"'date' missing or not string in meta\"\n    assert \"prepared_by\" in meta and isinstance(meta[\"prepared_by\"], str), \"'prepared_by' missing or not string in meta\"\n\ntest_root_endpoint_service_metadata()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 23, in <module>\n  File \"<string>\", line 18, in test_root_endpoint_service_metadata\nAssertionError: 'meta' field missing or not an object in response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-01T16:37:50.533Z",
    "modified": "2025-11-01T16:39:08.391Z"
  },
  {
    "projectId": "09b75804-f482-46fe-a5ed-99058e1cf33c",
    "testId": "11871d66-41c6-4161-84e0-4951efbef5ec",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC002-test_health_endpoint_status_check",
    "description": "Verify that the '/health' endpoint returns the health status of the service with HTTP 200 status and valid health schema.",
    "code": "import requests\nimport time\n\nBASE_KMS1 = \"http://127.0.0.1:9010\"\nBASE_KMS2 = \"http://127.0.0.1:9020\"\n\nHEADERS_KMS1 = {\n    \"X-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n    \"X-Slave-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n    \"Connection\": \"close\"\n}\n\nHEADERS_KMS2 = {\n    \"X-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n    \"X-Slave-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n    \"Connection\": \"close\"\n}\n\nHEADERS_KME_VERIFY = {\n    \"X-KMS-ID\": \"KMS-1\",\n    \"Connection\": \"close\"\n}\n\ndef test_health_endpoint_status_check():\n    timeout = 5\n    enc_keys_url = f\"{BASE_KMS1}/api/v1/keys/enc_keys\"\n    kme_verify_url = f\"{BASE_KMS2}/api/v1/kme/verify\"\n    dec_keys_url = f\"{BASE_KMS2}/api/v1/keys/dec_keys\"\n    \n    for i in range(10):\n        # Step 1: Request 2 encryption keys size 256 from KMS-1\n        enc_payload = {\"number\": 2, \"size\": 256}\n        try:\n            resp_enc = requests.post(enc_keys_url, headers=HEADERS_KMS1, json=enc_payload, timeout=timeout)\n        except requests.exceptions.RequestException as e:\n            raise AssertionError(f\"KMS-1 /enc_keys request failed on iteration {i+1}: {e}\")\n        \n        assert resp_enc.status_code == 200, f\"KMS-1 /enc_keys returned {resp_enc.status_code} on iteration {i+1}\"\n        \n        try:\n            enc_resp_json = resp_enc.json()\n        except Exception:\n            raise AssertionError(f\"KMS-1 /enc_keys response is not valid JSON on iteration {i+1}\")\n        \n        # Validate response contains 2 keys\n        if not isinstance(enc_resp_json, dict):\n            raise AssertionError(f\"KMS-1 /enc_keys response is not a dict on iteration {i+1}\")\n        \n        # Assuming keys are returned under a list key \"keys\" each with \"key_ID\"\n        keys = enc_resp_json.get(\"keys\")\n        assert isinstance(keys, list) and len(keys) == 2, f\"KMS-1 /enc_keys keys count invalid on iteration {i+1}\"\n        for key in keys:\n            assert isinstance(key, dict), f\"Key is not a dict on iteration {i+1}\"\n            assert \"key_ID\" in key and isinstance(key[\"key_ID\"], str) and key[\"key_ID\"], f\"Invalid key_ID in key on iteration {i+1}\"\n        \n        key_ids = [k[\"key_ID\"] for k in keys]\n        \n        # Step 2: Verify KMS-2 /api/v1/kme/verify returns all_verified=true for those key IDs\n        verify_payload = {\"key_IDs\": key_ids}\n        try:\n            resp_verify = requests.post(kme_verify_url, headers=HEADERS_KME_VERIFY, json=verify_payload, timeout=timeout)\n        except requests.exceptions.ConnectionError:\n            raise ConnectionError(\"KMS-2 API at /api/v1/kme/verify is not reachable\")\n        except requests.exceptions.RequestException as e:\n            raise AssertionError(f\"KMS-2 /kme/verify request failed on iteration {i+1}: {e}\")\n        \n        assert resp_verify.status_code == 200, f\"KMS-2 /kme/verify returned {resp_verify.status_code} on iteration {i+1}\"\n        try:\n            verify_json = resp_verify.json()\n        except Exception:\n            raise AssertionError(f\"KMS-2 /kme/verify response not JSON on iteration {i+1}\")\n        \n        # all_verified must be True\n        assert verify_json.get(\"all_verified\") is True, f\"KMS-2 /kme/verify all_verified not true on iteration {i+1}\"\n        \n        # Step 3: On KMS-2 request decryption keys for those key IDs with swapped headers\n        dec_payload = {\"key_IDs\": key_ids}\n        try:\n            resp_dec = requests.post(dec_keys_url, headers=HEADERS_KMS2, json=dec_payload, timeout=timeout)\n        except requests.exceptions.RequestException as e:\n            raise AssertionError(f\"KMS-2 /dec_keys request failed on iteration {i+1}: {e}\")\n        \n        assert resp_dec.status_code == 200, f\"KMS-2 /dec_keys returned {resp_dec.status_code} on iteration {i+1}\"\n        try:\n            dec_resp_json = resp_dec.json()\n        except Exception:\n            raise AssertionError(f\"KMS-2 /dec_keys response is not JSON on iteration {i+1}\")\n        \n        # Validate returned keys correspond to requested key_IDs and are consumed\n        dec_keys = dec_resp_json.get(\"keys\")\n        assert isinstance(dec_keys, list) and len(dec_keys) == len(key_ids), f\"KMS-2 /dec_keys keys count invalid on iteration {i+1}\"\n        returned_ids = [k.get(\"key_ID\") for k in dec_keys if isinstance(k, dict) and \"key_ID\" in k]\n        assert set(returned_ids) == set(key_ids), f\"KMS-2 /dec_keys returned keys mismatch on iteration {i+1}\"\n        \n        # Enforce no reuse: On next iteration the same keys should not be returned, so will request new keys next iteration\n        \n        time.sleep(0.1)  # brief pause to avoid flooding\n    \n    # Step 4: Verify /health endpoint returns 200 with valid schema (at KMS-1 as base)\n    health_url = f\"{BASE_KMS1}/health\"\n    try:\n        resp_health = requests.get(health_url, timeout=30, headers={\"Connection\": \"close\"})\n    except requests.exceptions.RequestException as e:\n        raise AssertionError(f\"Health endpoint request failed: {e}\")\n    \n    assert resp_health.status_code == 200, f\"/health endpoint returned {resp_health.status_code}\"\n    try:\n        health_json = resp_health.json()\n    except Exception:\n        raise AssertionError(\"/health response is not valid JSON\")\n    \n    # Assuming health schema requires at least a \"status\" key with \"healthy\" or similar\n    assert \"status\" in health_json, \"Health response missing 'status' key\"\n    assert isinstance(health_json[\"status\"], str) and health_json[\"status\"], \"Health 'status' is empty or not string\"\n\ntest_health_endpoint_status_check()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 34, in test_health_endpoint_status_check\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 116, in <module>\n  File \"<string>\", line 36, in test_health_endpoint_status_check\nAssertionError: KMS-1 /enc_keys request failed on iteration 1: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-01T16:37:50.539Z",
    "modified": "2025-11-01T16:39:45.054Z"
  },
  {
    "projectId": "09b75804-f482-46fe-a5ed-99058e1cf33c",
    "testId": "7bbf2289-515a-43f1-ba1e-ecf4447a95d7",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC003-test_post_enc_keys_request_encryption_keys",
    "description": "Test the '/api/v1/keys/enc_keys' POST endpoint to ensure it returns the requested number of encryption keys linked to the specified master and slave SAE IDs, triggers synchronization with peer KMS, and responds within 2 seconds.",
    "code": "import requests\nimport time\n\nBASE_KMS1 = \"http://127.0.0.1:9010\"\nBASE_KMS2 = \"http://127.0.0.1:9020\"\nTIMEOUT = 5\n\nX_SAE_ID_KMS1 = \"25840139-0dd4-49ae-ba1e-b86731601803\"\nX_SLAVE_SAE_ID_KMS1 = \"c565d5aa-8670-4446-8471-b0e53e315d2a\"\n\nX_SAE_ID_KMS2 = X_SLAVE_SAE_ID_KMS1\nX_SLAVE_SAE_ID_KMS2 = X_SAE_ID_KMS1\n\nHEADERS_KMS1 = {\n    \"X-SAE-ID\": X_SAE_ID_KMS1,\n    \"X-Slave-SAE-ID\": X_SLAVE_SAE_ID_KMS1,\n    \"Connection\": \"close\"\n}\n\nHEADERS_KMS2_VERIFY = {\n    \"X-KMS-ID\": \"KMS-1\",\n    \"Connection\": \"close\"\n}\n\nHEADERS_KMS2_DEC_KEYS = {\n    \"X-SAE-ID\": X_SAE_ID_KMS2,\n    \"X-Slave-SAE-ID\": X_SLAVE_SAE_ID_KMS2,\n    \"Connection\": \"close\"\n}\n\ndef test_post_enc_keys_request_encryption_keys():\n    for i in range(10):\n        # Step 1: On KMS-1 call /api/v1/keys/enc_keys\n        url_enc_keys = f\"{BASE_KMS1}/api/v1/keys/enc_keys\"\n        payload_enc = {\"number\": 2, \"size\": 256}\n\n        start_time = time.time()\n        try:\n            resp_enc = requests.post(url_enc_keys, headers=HEADERS_KMS1, json=payload_enc, timeout=TIMEOUT)\n        except requests.exceptions.RequestException as e:\n            raise AssertionError(f\"KMS-1 /enc_keys request failed on iteration {i+1}: {e}\")\n        elapsed_enc = time.time() - start_time\n\n        assert resp_enc.status_code == 200, f\"KMS-1 /enc_keys returned status {resp_enc.status_code}, iteration {i+1}\"\n        assert elapsed_enc <= 2, f\"KMS-1 /enc_keys response time {elapsed_enc:.2f}s exceeded 2s, iteration {i+1}\"\n\n        try:\n            data_enc = resp_enc.json()\n        except ValueError:\n            raise AssertionError(f\"KMS-1 /enc_keys returned invalid JSON, iteration {i+1}\")\n\n        # Validate that keys returned and extract key IDs\n        keys = data_enc.get(\"keys\") or data_enc.get(\"key_IDs\") or data_enc.get(\"key_ids\")\n        if keys is None:\n            # If no \"keys\" field, fallback try keys list with subfields\n            keys = []\n            if isinstance(data_enc, dict):\n                # try to detect keys in data_enc values\n                for v in data_enc.values():\n                    if isinstance(v, list):\n                        keys = v\n                        break\n        assert isinstance(keys, list), f\"KMS-1 /enc_keys response keys field missing or not list, iteration {i+1}\"\n        assert len(keys) == 2, f\"KMS-1 /enc_keys returned {len(keys)} keys, expected 2, iteration {i+1}\"\n\n        key_ids = []\n        # If keys are dict with id fields\n        for k in keys:\n            if isinstance(k, dict):\n                kid = k.get(\"key_ID\") or k.get(\"key_id\") or k.get(\"id\")\n                if kid:\n                    key_ids.append(kid)\n            elif isinstance(k, str):\n                key_ids.append(k)\n        assert len(key_ids) == 2, f\"Failed to extract 2 key IDs from keys response, iteration {i+1}\"\n\n        # Step 2: Verify KMS-2 /api/v1/kme/verify returns all_verified=true\n        url_verify = f\"{BASE_KMS2}/api/v1/kme/verify\"\n        payload_verify = {\"key_IDs\": key_ids}\n\n        try:\n            resp_verify = requests.post(url_verify, headers=HEADERS_KMS2_VERIFY, json=payload_verify, timeout=TIMEOUT)\n        except requests.exceptions.RequestException as e:\n            raise AssertionError(f\"KMS-2 /kme/verify request failed on iteration {i+1} (KMS-2 might be unreachable): {e}\")\n\n        assert resp_verify.status_code == 200, f\"KMS-2 /kme/verify returned status {resp_verify.status_code}, iteration {i+1}\"\n\n        try:\n            data_verify = resp_verify.json()\n        except ValueError:\n            raise AssertionError(f\"KMS-2 /kme/verify returned invalid JSON, iteration {i+1}\")\n\n        all_verified = data_verify.get(\"all_verified\")\n        assert all_verified is True, f\"KMS-2 /kme/verify all_verified!=True, iteration {i+1}\"\n\n        # Step 3: On KMS-2 call /api/v1/keys/dec_keys for those key IDs with headers swapped\n        url_dec_keys = f\"{BASE_KMS2}/api/v1/keys/dec_keys\"\n        payload_dec = {\"key_IDs\": key_ids}\n\n        start_time_dec = time.time()\n        try:\n            resp_dec = requests.post(url_dec_keys, headers=HEADERS_KMS2_DEC_KEYS, json=payload_dec, timeout=TIMEOUT)\n        except requests.exceptions.RequestException as e:\n            raise AssertionError(f\"KMS-2 /dec_keys request failed on iteration {i+1}: {e}\")\n        elapsed_dec = time.time() - start_time_dec\n\n        assert resp_dec.status_code == 200, f\"KMS-2 /dec_keys returned status {resp_dec.status_code}, iteration {i+1}\"\n        assert elapsed_dec <= 2, f\"KMS-2 /dec_keys response time {elapsed_dec:.2f}s exceeded 2s, iteration {i+1}\"\n\n        try:\n            data_dec = resp_dec.json()\n        except ValueError:\n            raise AssertionError(f\"KMS-2 /dec_keys returned invalid JSON, iteration {i+1}\")\n\n        # Verify returned keys for consumption\n        keys_dec = data_dec.get(\"keys\") or data_dec.get(\"key_IDs\") or data_dec.get(\"key_ids\")\n        assert isinstance(keys_dec, list), f\"KMS-2 /dec_keys keys field missing or not list, iteration {i+1}\"\n        assert len(keys_dec) == 2, f\"KMS-2 /dec_keys returned {len(keys_dec)} keys, expected 2, iteration {i+1}\"\n\n    print(\"test_post_enc_keys_request_encryption_keys passed 10 sequential iterations.\")\n\ntest_post_enc_keys_request_encryption_keys()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 39, in test_post_enc_keys_request_encryption_keys\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 122, in <module>\n  File \"<string>\", line 41, in test_post_enc_keys_request_encryption_keys\nAssertionError: KMS-1 /enc_keys request failed on iteration 1: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-01T16:37:50.548Z",
    "modified": "2025-11-01T16:39:03.342Z"
  },
  {
    "projectId": "09b75804-f482-46fe-a5ed-99058e1cf33c",
    "testId": "4230ee35-1971-4b5d-9700-c09d6d0c9c9b",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC004-test_post_dec_keys_request_decryption_keys",
    "description": "Test the '/api/v1/keys/dec_keys' POST endpoint to ensure it returns the requested decryption keys marked as consumed, enforces no key reuse, and responds within 2 seconds.",
    "code": "import requests\nimport time\n\nBASE_ENDPOINT_KMS1 = \"http://127.0.0.1:9010\"\nBASE_ENDPOINT_KMS2 = \"http://127.0.0.1:9020\"\nTIMEOUT_SECONDS = 5\n\nHEADERS_KMS1_TO_KMS2 = {\n    \"X-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n    \"X-Slave-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n    \"Connection\": \"close\"\n}\n\nHEADERS_KMS2_TO_KMS1 = {\n    \"X-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n    \"X-Slave-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n    \"Connection\": \"close\"\n}\n\nHEADERS_KMS1_KME = {\n    \"X-KMS-ID\": \"KMS-1\",\n    \"Connection\": \"close\"\n}\n\nHEADERS_KMS2_KME = {\n    \"X-KMS-ID\": \"KMS-2\",\n    \"Connection\": \"close\"\n}\n\n\ndef test_post_dec_keys_request_decryption_keys():\n    enc_keys_url = f\"{BASE_ENDPOINT_KMS1}/api/v1/keys/enc_keys\"\n    kme_verify_url = f\"{BASE_ENDPOINT_KMS2}/api/v1/kme/verify\"\n    dec_keys_url = f\"{BASE_ENDPOINT_KMS2}/api/v1/keys/dec_keys\"\n\n    number_keys = 2\n    key_size = 256\n    payload_enc = {\"number\": number_keys, \"size\": key_size}\n\n    for iteration in range(10):\n        try:\n            # Step 1: Request encryption keys from KMS-1\n            start_enc = time.time()\n            response_enc = requests.post(\n                enc_keys_url,\n                headers=HEADERS_KMS1_TO_KMS2,\n                json=payload_enc,\n                timeout=TIMEOUT_SECONDS,\n            )\n            elapsed_enc = time.time() - start_enc\n            assert response_enc.status_code == 200, f\"Enc keys request failed, status: {response_enc.status_code}\"\n            assert elapsed_enc <= 2, f\"Encryption key request took too long: {elapsed_enc:.2f}s\"\n\n            data_enc = response_enc.json()\n            # Validate keys array presence and length\n            keys = data_enc.get(\"keys\")\n            assert isinstance(keys, list), \"Response missing 'keys' list\"\n            assert len(keys) == number_keys, f\"Expected {number_keys} keys but got {len(keys)}\"\n\n            # Extract key IDs for verification and decryption request\n            key_ids = []\n            for key_item in keys:\n                kid = key_item.get(\"key_ID\")\n                assert isinstance(kid, str) and kid.strip(), \"Invalid or missing key_ID\"\n                key_ids.append(kid)\n\n            # Step 2: Verify keys on KMS-2 via /api/v1/kme/verify\n            verify_payload = {\"key_IDs\": key_ids}\n            start_verify = time.time()\n            response_verify = requests.post(\n                kme_verify_url,\n                headers=HEADERS_KMS2_KME,\n                json=verify_payload,\n                timeout=TIMEOUT_SECONDS,\n            )\n            elapsed_verify = time.time() - start_verify\n            assert response_verify.status_code == 200, f\"KME verify request failed, status: {response_verify.status_code}\"\n            assert elapsed_verify <= 2, f\"KME verify request took too long: {elapsed_verify:.2f}s\"\n\n            verify_data = response_verify.json()\n            all_verified = verify_data.get(\"all_verified\")\n            assert all_verified is True, f\"Keys not all verified on KMS-2: {verify_data}\"\n\n            # Step 3: Request decryption keys from KMS-2 with swapped headers\n            dec_payload = {\"key_IDs\": key_ids}\n            start_dec = time.time()\n            response_dec = requests.post(\n                dec_keys_url,\n                headers=HEADERS_KMS2_TO_KMS1,\n                json=dec_payload,\n                timeout=TIMEOUT_SECONDS,\n            )\n            elapsed_dec = time.time() - start_dec\n            assert response_dec.status_code == 200, f\"Dec keys request failed, status: {response_dec.status_code}\"\n            assert elapsed_dec <= 2, f\"Decryption key request took too long: {elapsed_dec:.2f}s\"\n\n            dec_data = response_dec.json()\n            dec_keys = dec_data.get(\"keys\")\n            assert isinstance(dec_keys, list), \"Response missing 'keys' list on decryption keys request\"\n            assert len(dec_keys) == number_keys, f\"Expected {number_keys} decryption keys, got {len(dec_keys)}\"\n\n            # Confirm returned keys match requested key IDs and marked consumed\n            returned_key_ids = [k.get(\"key_ID\") for k in dec_keys if \"key_ID\" in k]\n            assert set(returned_key_ids) == set(key_ids), \"Returned decryption keys do not match requested key IDs\"\n\n            for key_obj in dec_keys:\n                consumed = key_obj.get(\"consumed\")\n                assert consumed is True, \"Decryption key not marked as consumed\"\n\n            # Step 4: Attempt to reuse keys (should not be reissued)\n            # Request again decryption keys with the same IDs - expect failure or empty response or error\n            reuse_payload = {\"key_IDs\": key_ids}\n            try:\n                reuse_response = requests.post(\n                    dec_keys_url,\n                    headers=HEADERS_KMS2_TO_KMS1,\n                    json=reuse_payload,\n                    timeout=TIMEOUT_SECONDS,\n                )\n            except requests.exceptions.RequestException as e:\n                # If KMS-2 unreachable, report clearly\n                raise RuntimeError(f\"KMS-2 is not reachable during reuse check: {e}\")\n\n            # Validate reuse response: should not return keys as these are consumed\n            if reuse_response.status_code == 200:\n                reuse_data = reuse_response.json()\n                reuse_keys = reuse_data.get(\"keys\", [])\n                # Should be empty or none of the requested keys should be returned\n                if reuse_keys:\n                    reuse_returned_key_ids = [k.get(\"key_ID\") for k in reuse_keys if \"key_ID\" in k]\n                    intersection = set(reuse_returned_key_ids).intersection(set(key_ids))\n                    assert len(intersection) == 0, \"Keys reused which should not happen\"\n            else:\n                # If error returned (e.g. 400 or 404) it is acceptable behavior for reused keys\n                assert reuse_response.status_code in (400, 404), f\"Unexpected status for reused keys request: {reuse_response.status_code}\"\n\n        except requests.exceptions.ConnectionError:\n            raise RuntimeError(\"KMS-2 service is not reachable at http://127.0.0.1:9020\")\n\n        except Exception:\n            raise\n\ntest_post_dec_keys_request_decryption_keys()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 143, in <module>\n  File \"<string>\", line 44, in test_post_dec_keys_request_decryption_keys\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-01T16:37:50.554Z",
    "modified": "2025-11-01T16:39:50.166Z"
  },
  {
    "projectId": "09b75804-f482-46fe-a5ed-99058e1cf33c",
    "testId": "399b0428-2e4f-4a2b-9bb4-f2f190d81a80",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC005-test_get_key_status_for_master_sae_id",
    "description": "Verify the '/api/v1/keys/{master_sae_id}/status' GET endpoint returns correct stored key counts and size limits for the given master SAE ID with HTTP 200 status.",
    "code": "import requests\nimport time\n\ndef test_get_key_status_for_master_sae_id():\n    kms1_base = \"http://127.0.0.1:9010\"\n    kms2_base = \"http://127.0.0.1:9020\"\n    timeout = 5\n    master_sae_id = \"25840139-0dd4-49ae-ba1e-b86731601803\"\n    slave_sae_id = \"c565d5aa-8670-4446-8471-b0e53e315d2a\"\n    headers_kms1_enc = {\n        \"X-SAE-ID\": master_sae_id,\n        \"X-Slave-SAE-ID\": slave_sae_id,\n        \"Connection\": \"close\"\n    }\n    headers_kms2_kme = {\n        \"X-KMS-ID\": \"KMS-1\",\n        \"Connection\": \"close\"\n    }\n    headers_kms2_dec = {\n        \"X-SAE-ID\": slave_sae_id,\n        \"X-Slave-SAE-ID\": master_sae_id,\n        \"Connection\": \"close\"\n    }\n\n    enc_keys_url = f\"{kms1_base}/api/v1/keys/enc_keys\"\n    kme_verify_url = f\"{kms2_base}/api/v1/kme/verify\"\n    dec_keys_url = f\"{kms2_base}/api/v1/keys/dec_keys\"\n    key_status_url = f\"{kms1_base}/api/v1/keys/{master_sae_id}/status\"\n\n    for _ in range(10):\n        try:\n            # Step 1: On KMS-1 call /api/v1/keys/enc_keys to get 2 keys size 256\n            payload_enc = {\"number\": 2, \"size\": 256}\n            resp_enc = requests.post(enc_keys_url, headers=headers_kms1_enc, json=payload_enc, timeout=timeout)\n            assert resp_enc.status_code == 200, f\"KMS-1 enc_keys failed with status {resp_enc.status_code}\"\n            resp_enc_json = resp_enc.json()\n            assert isinstance(resp_enc_json, dict), \"Response for enc_keys is not a JSON object\"\n            keys = resp_enc_json.get(\"keys\")\n            assert keys is not None and isinstance(keys, list), \"Response missing 'keys' list\"\n            assert len(keys) == 2, f\"Expected 2 keys, got {len(keys)}\"\n            key_ids = [k.get(\"key_ID\") for k in keys]\n            for kid in key_ids:\n                assert isinstance(kid, str) and kid, \"Invalid or missing key_ID\"\n            for k in keys:\n                size = k.get(\"size\")\n                assert size == 256, f\"Key size expected 256, got {size}\"\n\n            # Step 2: Verify all keys on KMS-2 /api/v1/kme/verify returns all_verified=true\n            verify_payload = {\"key_IDs\": key_ids}\n            headers_kms2_kme[\"Connection\"] = \"close\"\n            resp_verify = requests.post(kme_verify_url, headers=headers_kms2_kme, json=verify_payload, timeout=timeout)\n            if resp_verify.status_code == 404 or resp_verify.status_code >= 500:\n                raise ConnectionError(\"KMS-2 verification endpoint not reachable or error\")\n            assert resp_verify.status_code == 200, f\"KMS-2 kme/verify failed with status {resp_verify.status_code}\"\n            resp_verify_json = resp_verify.json()\n            all_verified = resp_verify_json.get(\"all_verified\")\n            assert all_verified is True, \"Keys not all verified on KMS-2\"\n\n            # Step 3: On KMS-2 call /api/v1/keys/dec_keys for those key_IDs with headers swapped\n            payload_dec = {\"key_IDs\": key_ids}\n            resp_dec = requests.post(dec_keys_url, headers=headers_kms2_dec, json=payload_dec, timeout=timeout)\n            assert resp_dec.status_code == 200, f\"KMS-2 dec_keys failed with status {resp_dec.status_code}\"\n            resp_dec_json = resp_dec.json()\n            dec_keys = resp_dec_json.get(\"keys\")\n            assert isinstance(dec_keys, list), \"dec_keys response missing 'keys' list\"\n            dec_key_ids = [k.get(\"key_ID\") for k in dec_keys]\n            assert set(dec_key_ids) == set(key_ids), \"Mismatch between requested and returned decryption key IDs\"\n\n            # Step 4: Verify /api/v1/keys/{master_sae_id}/status returns correct counts and size limits\n            resp_status = requests.get(key_status_url, headers={\"X-Slave-SAE-ID\": slave_sae_id, \"Connection\": \"close\"}, timeout=timeout)\n            assert resp_status.status_code == 200, f\"Key status endpoint failed with status {resp_status.status_code}\"\n            status_json = resp_status.json()\n            stored_keys_count = status_json.get(\"stored_keys_count\")\n            size_limit = status_json.get(\"size_limit\")\n            # As keys are consumed after dec_keys call, stored_keys_count might be 0 or decreasing but size_limit should be 256 or consistent\n            assert stored_keys_count is not None and isinstance(stored_keys_count, int), \"stored_keys_count missing or invalid\"\n            assert size_limit is not None and isinstance(size_limit, int), \"size_limit missing or invalid\"\n            # We expect size_limit to be at least 256 (per key size used)\n            assert size_limit >= 256, f\"size_limit expected >=256, got {size_limit}\"\n\n        except requests.ConnectionError:\n            raise RuntimeError(\"KMS-2 service is not reachable at http://127.0.0.1:9020\")\n        except Exception:\n            raise\n        time.sleep(0.2)  # small delay between iterations to avoid rate limiting\n\ntest_get_key_status_for_master_sae_id()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 87, in <module>\n  File \"<string>\", line 34, in test_get_key_status_for_master_sae_id\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-01T16:37:50.566Z",
    "modified": "2025-11-01T16:40:05.525Z"
  },
  {
    "projectId": "09b75804-f482-46fe-a5ed-99058e1cf33c",
    "testId": "c7ab473c-880f-4ad4-96d9-ded5534f277c",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC006-test_post_kme_sync_receive_keys_for_synchronization",
    "description": "Test the '/api/v1/kme/sync' POST endpoint to verify it accepts keys for synchronization from peer KMS with valid X-KMS-ID header and returns HTTP 200 status.",
    "code": "import requests\nimport time\n\nBASE_KMS_1 = \"http://127.0.0.1:9010\"\nBASE_KMS_2 = \"http://127.0.0.1:9020\"\nTIMEOUT = 5\n\nHEADERS_KMS_1 = {\n    \"X-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n    \"X-Slave-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n    \"Connection\": \"close\"\n}\nHEADERS_KMS_2 = {\n    \"X-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n    \"X-Slave-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n    \"Connection\": \"close\"\n}\n\nX_KMS_ID_KMS_1 = \"KMS-1\"\nX_KMS_ID_KMS_2 = \"KMS-2\"\n\n\ndef test_post_kme_sync_receive_keys_for_synchronization():\n    for i in range(10):\n        # Step 1: On KMS-1 call /api/v1/keys/enc_keys with 2 keys of size 256\n        enc_keys_payload = {\"number\": 2, \"size\": 256}\n        try:\n            r_enc = requests.post(\n                f\"{BASE_KMS_1}/api/v1/keys/enc_keys\",\n                headers=HEADERS_KMS_1,\n                json=enc_keys_payload,\n                timeout=TIMEOUT,\n                )\n            r_enc.raise_for_status()\n        except requests.exceptions.RequestException as e:\n            assert False, f\"KMS-1 /enc_keys request failed at iteration {i+1}: {e}\"\n        enc_keys_data = r_enc.json()\n        # Expecting keys returned as a list or dict containing keys with IDs\n        # We try to extract key_IDs for verification and dec_keys request\n        # Assume response structure includes a list of keys with an 'ID' or 'key_ID' field.\n        # We'll check multiple common possible structures.\n        key_ids = []\n        if isinstance(enc_keys_data, dict):\n            keys = enc_keys_data.get(\"keys\")\n            if keys and isinstance(keys, list):\n                for key in keys:\n                    if \"ID\" in key:\n                        key_ids.append(key[\"ID\"])\n                    elif \"key_ID\" in key:\n                        key_ids.append(key[\"key_ID\"])\n                    elif \"KeyID\" in key:\n                        key_ids.append(key[\"KeyID\"])\n            elif isinstance(enc_keys_data.get(\"data\"), list):\n                for key in enc_keys_data.get(\"data\"):\n                    if \"ID\" in key:\n                        key_ids.append(key[\"ID\"])\n            elif isinstance(enc_keys_data, list):\n                for key in enc_keys_data:\n                    if isinstance(key, dict):\n                        if \"ID\" in key:\n                            key_ids.append(key[\"ID\"])\n        elif isinstance(enc_keys_data, list):\n            for key in enc_keys_data:\n                if isinstance(key, dict) and \"ID\" in key:\n                    key_ids.append(key[\"ID\"])\n\n        assert len(key_ids) >= 2, f\"Expected at least 2 keys from enc_keys, got {len(key_ids)} at iteration {i+1}\"\n\n        # Step 2: Verify KMS-2 /api/v1/kme/verify returns all_verified=true for those key IDs\n        verify_headers = {\"X-KMS-ID\": X_KMS_ID_KMS_2, \"Connection\": \"close\"}\n        try:\n            r_verify = requests.post(\n                f\"{BASE_KMS_2}/api/v1/kme/verify\",\n                headers=verify_headers,\n                timeout=TIMEOUT,\n            )\n            r_verify.raise_for_status()\n        except requests.exceptions.RequestException as e:\n            assert False, f\"KMS-2 /kme/verify request failed at iteration {i+1}: {e}\"\n        verify_data = r_verify.json()\n        # Validate all_verified = true in response\n        assert (\n            isinstance(verify_data, dict)\n            and verify_data.get(\"all_verified\") is True\n        ), f\"/kme/verify did not return all_verified=true at iteration {i+1}: {verify_data}\"\n\n        # Step 3: On KMS-2 call /api/v1/keys/dec_keys for those key IDs with swapped headers\n        dec_keys_payload = {\"key_IDs\": key_ids}\n        try:\n            r_dec = requests.post(\n                f\"{BASE_KMS_2}/api/v1/keys/dec_keys\",\n                headers=HEADERS_KMS_2,\n                json=dec_keys_payload,\n                timeout=TIMEOUT,\n            )\n            r_dec.raise_for_status()\n        except requests.exceptions.RequestException as e:\n            assert False, f\"KMS-2 /dec_keys request failed at iteration {i+1}: {e}\"\n        dec_keys_data = r_dec.json()\n        dec_key_ids = []\n        if isinstance(dec_keys_data, dict):\n            keys = dec_keys_data.get(\"keys\")\n            if keys and isinstance(keys, list):\n                for key in keys:\n                    if \"ID\" in key:\n                        dec_key_ids.append(key[\"ID\"])\n                    elif \"key_ID\" in key:\n                        dec_key_ids.append(key[\"key_ID\"])\n                    elif \"KeyID\" in key:\n                        dec_key_ids.append(key[\"KeyID\"])\n            elif isinstance(dec_keys_data.get(\"data\"), list):\n                for key in dec_keys_data.get(\"data\"):\n                    if \"ID\" in key:\n                        dec_key_ids.append(key[\"ID\"])\n            elif isinstance(dec_keys_data, list):\n                for key in dec_keys_data:\n                    if isinstance(key, dict):\n                        if \"ID\" in key:\n                            dec_key_ids.append(key[\"ID\"])\n        elif isinstance(dec_keys_data, list):\n            for key in dec_keys_data:\n                if isinstance(key, dict) and \"ID\" in key:\n                    dec_key_ids.append(key[\"ID\"])\n\n        assert set(key_ids).issubset(set(dec_key_ids)), f\"Returned dec_keys do not include all requested keys at iteration {i+1}\"\n\n        # Step 4: On KMS-1 call /api/v1/kme/sync with keys from enc_keys to simulate sync\n        sync_payload = {\"keys\": enc_keys_data.get(\"keys\") if isinstance(enc_keys_data, dict) else enc_keys_data}\n        if not sync_payload[\"keys\"]:\n            sync_payload = {\"keys\": enc_keys_data}\n\n        sync_headers = {\"X-KMS-ID\": X_KMS_ID_KMS_2, \"Connection\": \"close\"}\n\n        try:\n            r_sync = requests.post(\n                f\"{BASE_KMS_1}/api/v1/kme/sync\",\n                headers=sync_headers,\n                json=sync_payload,\n                timeout=TIMEOUT,\n            )\n            r_sync.raise_for_status()\n        except requests.exceptions.RequestException as e:\n            assert False, f\"KMS-1 /kme/sync request failed at iteration {i+1}: {e}\"\n        assert r_sync.status_code == 200, f\"/kme/sync did not return 200 OK at iteration {i+1}\"\n\n        time.sleep(0.1)\n\n\ntest_post_kme_sync_receive_keys_for_synchronization()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 28, in test_post_kme_sync_receive_keys_for_synchronization\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 149, in <module>\n  File \"<string>\", line 36, in test_post_kme_sync_receive_keys_for_synchronization\nAssertionError: KMS-1 /enc_keys request failed at iteration 1: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-01T16:37:50.571Z",
    "modified": "2025-11-01T16:39:50.179Z"
  },
  {
    "projectId": "09b75804-f482-46fe-a5ed-99058e1cf33c",
    "testId": "ec27bf20-bdba-4b4b-8e4c-f42cd3f28cba",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC007-test_post_kme_verify_keys_exist",
    "description": "Test the '/api/v1/kme/verify' POST endpoint to confirm it verifies the existence of keys on the target KMS using the X-KMS-ID header and returns HTTP 200 status.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_KMS1 = \"http://127.0.0.1:9010\"\nBASE_KMS2 = \"http://127.0.0.1:9020\"\n\n\ndef test_post_kme_verify_keys_exist():\n    timeout = 5\n    enc_keys_url = f\"{BASE_KMS1}/api/v1/keys/enc_keys\"\n    verify_url = f\"{BASE_KMS2}/api/v1/kme/verify\"\n    dec_keys_url = f\"{BASE_KMS2}/api/v1/keys/dec_keys\"\n\n    headers_kms1 = {\n        \"X-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n        \"X-Slave-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n        \"Connection\": \"close\"\n    }\n    headers_kms2_verify = {\n        \"X-KMS-ID\": \"KMS-1\",\n        \"Connection\": \"close\"\n    }\n    headers_kms2_dec = {\n        \"X-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n        \"X-Slave-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n        \"Connection\": \"close\"\n    }\n\n    for _ in range(10):\n        try:\n            # Step 1: Request encryption keys from KMS-1\n            enc_req_payload = {\"number\": 2, \"size\": 256}\n            try:\n                enc_resp = requests.post(enc_keys_url, headers=headers_kms1, json=enc_req_payload, timeout=timeout)\n            except RequestException as e:\n                raise RuntimeError(f\"KMS-1 /api/v1/keys/enc_keys endpoint not reachable or failed: {e}\")\n            assert enc_resp.status_code == 200, f\"Expected 200 from KMS-1 enc_keys, got {enc_resp.status_code}\"\n            enc_resp_json = enc_resp.json()\n            assert isinstance(enc_resp_json, dict), \"KMS-1 enc_keys response is not a JSON object\"\n            assert \"keys\" in enc_resp_json or \"key_IDs\" in enc_resp_json, \"No keys or key_IDs in KMS-1 response\"\n            \n            # Extract key IDs for verification\n            # The response schema is not explicitly defined for keys key names,\n            # we assume keys are under \"keys\" or \"key_IDs\" as a list of dicts or strings.\n            if \"keys\" in enc_resp_json:\n                # keys is list of dicts, each having \"key_ID\" or \"id\"\n                keys_list = enc_resp_json[\"keys\"]\n                if keys_list and isinstance(keys_list, list):\n                    key_ids = []\n                    for k in keys_list:\n                        if isinstance(k, dict):\n                            if \"key_ID\" in k:\n                                key_ids.append(k[\"key_ID\"])\n                            elif \"id\" in k:\n                                key_ids.append(k[\"id\"])\n                            else:\n                                raise AssertionError(\"Key object missing key_ID or id\")\n                        elif isinstance(k, str):\n                            key_ids.append(k)\n                    assert len(key_ids) == 2, f\"Expected 2 keys, got {len(key_ids)}\"\n                else:\n                    raise AssertionError(\"keys field is not a list with expected keys\")\n            elif \"key_IDs\" in enc_resp_json:\n                key_ids = enc_resp_json[\"key_IDs\"]\n                assert isinstance(key_ids, list), \"key_IDs is not a list\"\n                assert len(key_ids) == 2, f\"Expected 2 key_IDs, got {len(key_ids)}\"\n            else:\n                raise AssertionError(\"No valid keys or key_IDs found in response\")\n\n            # Step 2: Verify keys exist on KMS-2 using /api/v1/kme/verify\n            verify_payload = {\"key_IDs\": key_ids}\n            try:\n                verify_resp = requests.post(verify_url, headers=headers_kms2_verify, json=verify_payload, timeout=timeout)\n            except RequestException as e:\n                raise RuntimeError(f\"KMS-2 /api/v1/kme/verify endpoint not reachable or failed: {e}\")\n            assert verify_resp.status_code == 200, f\"Expected 200 from KMS-2 kme/verify, got {verify_resp.status_code}\"\n\n            verify_resp_json = verify_resp.json()\n            assert isinstance(verify_resp_json, dict), \"KMS-2 kme/verify response is not a JSON object\"\n            assert verify_resp_json.get(\"all_verified\") is True, f\"Expected all_verified=True, got {verify_resp_json.get('all_verified')}\"\n\n            # Step 3: Request decryption keys from KMS-2 for those key IDs with headers swapped\n            dec_req_payload = {\"key_IDs\": key_ids}\n            try:\n                dec_resp = requests.post(dec_keys_url, headers=headers_kms2_dec, json=dec_req_payload, timeout=timeout)\n            except RequestException as e:\n                raise RuntimeError(f\"KMS-2 /api/v1/keys/dec_keys endpoint not reachable or failed: {e}\")\n            assert dec_resp.status_code == 200, f\"Expected 200 from KMS-2 dec_keys, got {dec_resp.status_code}\"\n            dec_resp_json = dec_resp.json()\n            assert isinstance(dec_resp_json, dict), \"KMS-2 dec_keys response is not a JSON object\"\n            # expect keys or similar in response\n            keys_returned = dec_resp_json.get(\"keys\") or dec_resp_json.get(\"key_IDs\") or dec_resp_json.get(\"decrypted_keys\")\n            assert keys_returned is not None, \"No keys returned by KMS-2 dec_keys\"\n            if isinstance(keys_returned, list):\n                # Should match requested keys and length 2\n                assert len(keys_returned) == 2, f\"Expected 2 keys in dec_keys response, got {len(keys_returned)}\"\n            else:\n                raise AssertionError(\"Keys returned by dec_keys is not a list\")\n\n        except AssertionError as ae:\n            raise AssertionError(f\"Assertion failed during iteration: {ae}\")\n\n        except RuntimeError as re:\n            raise RuntimeError(str(re))",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-01T16:37:50.576Z",
    "modified": "2025-11-01T16:39:03.362Z"
  },
  {
    "projectId": "09b75804-f482-46fe-a5ed-99058e1cf33c",
    "testId": "69f1c003-8857-4f27-b058-3203ebd4c963",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC008-test_get_kme_status",
    "description": "Verify the '/api/v1/kme/status' GET endpoint returns the current KME status with HTTP 200 status and valid response schema.",
    "code": "import requests\nimport time\n\nBASE_ENDPOINT_KMS_1 = \"http://127.0.0.1:9010\"\nBASE_ENDPOINT_KMS_2 = \"http://127.0.0.1:9020\"\n\nHEADERS_KMS_1 = {\n    \"X-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n    \"X-Slave-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n    \"Connection\": \"close\"\n}\n\nHEADERS_KMS_2 = {\n    \"X-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n    \"X-Slave-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n    \"Connection\": \"close\"\n}\n\ndef test_get_kme_status():\n    timeout = 5\n    enc_keys_url = f\"{BASE_ENDPOINT_KMS_1}/api/v1/keys/enc_keys\"\n    verify_url = f\"{BASE_ENDPOINT_KMS_2}/api/v1/kme/verify\"\n    dec_keys_url = f\"{BASE_ENDPOINT_KMS_2}/api/v1/keys/dec_keys\"\n    kme_status_url = f\"{BASE_ENDPOINT_KMS_1}/api/v1/kme/status\"\n\n    # Attempt to connect to KMS-2 to ensure availability\n    try:\n        # Simple GET for KME status on KMS-2 as availability check with Connection close\n        resp_kms2_status = requests.get(kme_status_url.replace(\"9010\",\"9020\"), timeout=timeout, headers={\"Connection\": \"close\"})\n        resp_kms2_status.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f\"KMS-2 service not reachable at {BASE_ENDPOINT_KMS_2}: {e}\")\n\n    for _ in range(10):\n        # 1) On KMS-1 call /api/v1/keys/enc_keys with given headers and payload\n        try:\n            payload_enc = {\"number\": 2, \"size\": 256}\n            r_enc = requests.post(enc_keys_url, headers=HEADERS_KMS_1, json=payload_enc, timeout=timeout)\n            r_enc.raise_for_status()\n        except requests.RequestException as e:\n            raise RuntimeError(f\"Failed to request encryption keys from KMS-1: {e}\")\n        enc_resp_json = r_enc.json()\n\n        # Validate response contains keys with key IDs and expected size\n        assert isinstance(enc_resp_json, dict), \"Encryption keys response is not a JSON object\"\n        # Expecting keys field or list, infer from returned data keys name\n        keys = enc_resp_json.get(\"keys\") or enc_resp_json.get(\"key_IDs\") or enc_resp_json.get(\"key_ids\") or enc_resp_json.get(\"keys_list\")\n        if keys is None:\n            # Fall back: find list of keys by checking dict values\n            keys = []\n            for v in enc_resp_json.values():\n                if isinstance(v, list) and len(v) == 2:\n                    keys = v\n                    break\n        assert isinstance(keys, list), \"Encryption keys not returned as list\"\n        assert len(keys) == 2, f\"Expected 2 keys but got {len(keys)}\"\n        # Each key should have an ID string, extract IDs\n        key_ids = []\n        for key in keys:\n            if isinstance(key, dict) and \"key_ID\" in key:\n                key_ids.append(key[\"key_ID\"])\n            elif isinstance(key, dict) and \"id\" in key:\n                key_ids.append(str(key[\"id\"]))\n            elif isinstance(key, str):\n                key_ids.append(key)\n            else:\n                # fallback: try first string or id field\n                if isinstance(key, dict):\n                    first_val = next(iter(key.values()), None)\n                    if isinstance(first_val, str):\n                        key_ids.append(first_val)\n        # Validate key_ids count\n        assert len(key_ids) == 2, \"Key IDs extraction failed or count mismatch\"\n\n        # 2) Verify on KMS-2 /api/v1/kme/verify returns all_verified=true for those keys\n        try:\n            headers_kms2_verify = {\"X-KMS-ID\": \"KMS-2\", \"Connection\": \"close\"}\n            r_verify = requests.post(verify_url, headers=headers_kms2_verify, json={\"key_IDs\": key_ids}, timeout=timeout)\n            r_verify.raise_for_status()\n        except requests.RequestException as e:\n            raise RuntimeError(f\"Failed KME verify on KMS-2: {e}\")\n\n        verify_resp = r_verify.json()\n        assert isinstance(verify_resp, dict), \"KME verify response is not a JSON object\"\n        assert verify_resp.get(\"all_verified\") is True, f\"Expected all_verified=true but got {verify_resp.get('all_verified')}\"\n\n        # 3) On KMS-2 call /api/v1/keys/dec_keys with swapped headers and those key IDs\n        try:\n            headers_dec_keys = HEADERS_KMS_2.copy()\n            payload_dec = {\"key_IDs\": key_ids}\n            r_dec = requests.post(dec_keys_url, headers=headers_dec_keys, json=payload_dec, timeout=timeout)\n            r_dec.raise_for_status()\n        except requests.RequestException as e:\n            raise RuntimeError(f\"Failed to request decryption keys from KMS-2: {e}\")\n\n        dec_resp_json = r_dec.json()\n        assert isinstance(dec_resp_json, dict), \"Decryption keys response is not a JSON object\"\n        dec_keys = dec_resp_json.get(\"keys\") or dec_resp_json.get(\"key_IDs\") or dec_resp_json.get(\"key_ids\") or dec_resp_json.get(\"keys_list\")\n        if dec_keys is None:\n            # Same fallback as above\n            dec_keys = []\n            for v in dec_resp_json.values():\n                if isinstance(v, list):\n                    dec_keys = v\n                    break\n        assert isinstance(dec_keys, list), \"Decryption keys not returned as list\"\n        assert len(dec_keys) == 2, f\"Expected 2 decryption keys but got {len(dec_keys)}\"\n\n        # 4) Wait a minimal pause before next iteration (optional)\n        time.sleep(0.1)\n\n    # Finally, verify the KME status endpoint on KMS-1 responds HTTP 200 with valid schema\n    try:\n        r_status = requests.get(kme_status_url, timeout=timeout, headers={\"Connection\": \"close\"})\n        r_status.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f\"Failed to get KME status from KMS-1: {e}\")\n\n    status_json = r_status.json()\n    assert isinstance(status_json, dict), \"KME status response is not a JSON object\"\n    # Validate expected keys in status JSON (schema not detailed, so basic check)\n    assert \"status\" in status_json or \"kme_status\" in status_json or \"state\" in status_json or len(status_json) > 0, \\\n        \"KME status response missing expected keys or empty\"\n\ntest_get_kme_status()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 29, in test_get_kme_status\n  File \"/var/task/requests/api.py\", line 73, in get\n    return request(\"get\", url, params=params, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 125, in <module>\n  File \"<string>\", line 32, in test_get_kme_status\nRuntimeError: KMS-2 service not reachable at http://127.0.0.1:9020: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-01T16:37:50.581Z",
    "modified": "2025-11-01T16:44:10.584Z"
  },
  {
    "projectId": "09b75804-f482-46fe-a5ed-99058e1cf33c",
    "testId": "25acae24-491e-4447-a9a4-5bb82bd0cb46",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC009-test_post_kme_pool_status",
    "description": "Test the '/api/v1/kme/pool/status' POST endpoint to ensure it returns the current key pool status with HTTP 200 status.",
    "code": "import requests\nfrom requests.exceptions import RequestException, ConnectionError, Timeout\n\nBASE_KMS1 = \"http://127.0.0.1:9010\"\nBASE_KMS2 = \"http://127.0.0.1:9020\"\n\nHEADERS_KMS1 = {\n    \"X-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n    \"X-Slave-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n    \"Connection\": \"close\"\n}\n\nHEADERS_KMS2 = {\n    \"X-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n    \"X-Slave-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n    \"Connection\": \"close\"\n}\n\nHEADERS_KME_KMS2 = {\n    \"X-KMS-ID\": \"KMS-2\",\n    \"Connection\": \"close\"\n}\n\nTIMEOUT = 5  # seconds, as per instruction\n\ndef test_post_kme_pool_status():\n    try:\n        for _ in range(10):\n            # Step 1: On KMS-1 call /api/v1/keys/enc_keys\n            enc_keys_payload = {\n                \"number\": 2,\n                \"size\": 256\n            }\n            r_enc = requests.post(\n                f\"{BASE_KMS1}/api/v1/keys/enc_keys\",\n                headers=HEADERS_KMS1,\n                json=enc_keys_payload,\n                timeout=TIMEOUT\n            )\n            assert r_enc.status_code == 200, f\"KMS-1 enc_keys call failed with status {r_enc.status_code}\"\n            enc_keys_resp = r_enc.json()\n            # Expect keys in response, assume list under 'keys' or similar, else collect key IDs safely\n            # From QKD standards and typical usage, keys will be identifiable by IDs; adapt as needed.\n            # We'll try to find key IDs in the response\n            # Typically the response might be like {\"keys\": [{\"key_ID\": \"abc\", ...}, {...}]}\n            # Let's extract key IDs:\n            key_ids = []\n            if isinstance(enc_keys_resp, dict) and 'keys' in enc_keys_resp:\n                for key_info in enc_keys_resp['keys']:\n                    if 'key_ID' in key_info:\n                        key_ids.append(key_info['key_ID'])\n            elif isinstance(enc_keys_resp, dict):\n                # Fallback, try keys field at top level\n                for k, v in enc_keys_resp.items():\n                    if isinstance(v, list):\n                        for item in v:\n                            if isinstance(item, dict) and 'key_ID' in item:\n                                key_ids.append(item['key_ID'])\n            if len(key_ids) < 2:\n                # Fallback: try if keys themselves are strings (key IDs)\n                if isinstance(enc_keys_resp, list):\n                    key_ids = enc_keys_resp\n                else:\n                    raise AssertionError(\"Unable to extract 2 key IDs from enc_keys response\")\n\n            assert len(key_ids) == 2, f\"Expected 2 key IDs, got {len(key_ids)}\"\n\n            # Step 2: Verify on KMS-2 /api/v1/kme/verify with X-KMS-ID header returns all_verified=true\n            verify_payload = {\n                \"key_IDs\": key_ids\n            }\n            r_verify = requests.post(\n                f\"{BASE_KMS2}/api/v1/kme/verify\",\n                headers=HEADERS_KME_KMS2,\n                json=verify_payload,\n                timeout=TIMEOUT\n            )\n            assert r_verify.status_code == 200, f\"KMS-2 kme/verify call failed with status {r_verify.status_code}\"\n            verify_resp = r_verify.json()\n            # Expect {\"all_verified\": true} or similar\n            assert isinstance(verify_resp, dict), \"kme/verify response is not a JSON object\"\n            assert verify_resp.get(\"all_verified\") is True, \"Not all keys verified on KMS-2\"\n\n            # Step 3: On KMS-2 call /api/v1/keys/dec_keys for those key IDs with headers swapped\n            dec_keys_payload = {\n                \"key_IDs\": key_ids\n            }\n            r_dec = requests.post(\n                f\"{BASE_KMS2}/api/v1/keys/dec_keys\",\n                headers=HEADERS_KMS2,\n                json=dec_keys_payload,\n                timeout=TIMEOUT\n            )\n            assert r_dec.status_code == 200, f\"KMS-2 dec_keys call failed with status {r_dec.status_code}\"\n            dec_keys_resp = r_dec.json()\n            # Verify keys returned match requested key_IDs (at least presence)\n            dec_key_ids = []\n            if isinstance(dec_keys_resp, dict) and 'keys' in dec_keys_resp:\n                for key_info in dec_keys_resp['keys']:\n                    if 'key_ID' in key_info:\n                        dec_key_ids.append(key_info['key_ID'])\n            elif isinstance(dec_keys_resp, dict):\n                for k, v in dec_keys_resp.items():\n                    if isinstance(v, list):\n                        for item in v:\n                            if isinstance(item, dict) and 'key_ID' in item:\n                                dec_key_ids.append(item['key_ID'])\n            elif isinstance(dec_keys_resp, list):\n                dec_key_ids = dec_keys_resp\n\n            for key_id in key_ids:\n                assert key_id in dec_key_ids, f\"Decryption key ID {key_id} not found in response\"\n\n        # Step 4: After completing 10 iterations, test /api/v1/kme/pool/status POST endpoint on KMS-1\n        r_pool_status = requests.post(\n            f\"{BASE_KMS1}/api/v1/kme/pool/status\",\n            headers={\"Connection\": \"close\"},\n            timeout=TIMEOUT\n        )\n        assert r_pool_status.status_code == 200, f\"kme/pool/status POST failed with status {r_pool_status.status_code}\"\n        # Response content check can be basic, as no schema provided\n        try:\n            resp_json = r_pool_status.json()\n            assert isinstance(resp_json, dict), \"kme/pool/status response is not a JSON object\"\n        except Exception:\n            raise AssertionError(\"kme/pool/status response is not valid JSON\")\n\n    except ConnectionError:\n        print(\"KMS-2 at http://127.0.0.1:9020 is not reachable.\")\n    except Timeout:\n        raise AssertionError(\"Request timed out\")\n    except RequestException as e:\n        raise AssertionError(f\"Request failed: {str(e)}\")\n\ntest_post_kme_pool_status()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 34, in test_post_kme_pool_status\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 135, in <module>\n  File \"<string>\", line 131, in test_post_kme_pool_status\nAssertionError: Request timed out\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-01T16:37:50.586Z",
    "modified": "2025-11-01T16:39:21.004Z"
  },
  {
    "projectId": "09b75804-f482-46fe-a5ed-99058e1cf33c",
    "testId": "eb446cfc-5864-42f5-8fd8-ed48d1551c5b",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC010-test_post_kme_pool_replenish",
    "description": "Test the '/api/v1/kme/pool/replenish' POST endpoint to verify it triggers key pool replenishment and returns HTTP 200 status.",
    "code": "import requests\nimport time\n\ndef test_post_kme_pool_replenish():\n    KMS1_BASE = \"http://127.0.0.1:9010\"\n    KMS2_BASE = \"http://127.0.0.1:9020\"\n    timeout = 5\n    enc_headers_kms1 = {\n        \"X-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n        \"X-Slave-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n        \"Connection\": \"close\"\n    }\n    dec_headers_kms2 = {\n        \"X-SAE-ID\": \"c565d5aa-8670-4446-8471-b0e53e315d2a\",\n        \"X-Slave-SAE-ID\": \"25840139-0dd4-49ae-ba1e-b86731601803\",\n        \"Connection\": \"close\"\n    }\n    kme_verify_headers = {\"X-KMS-ID\": \"KMS-2\", \"Connection\": \"close\"}\n\n    replenish_url = f\"{KMS2_BASE}/api/v1/kme/pool/replenish\"\n    enc_url = f\"{KMS1_BASE}/api/v1/keys/enc_keys\"\n    verify_url = f\"{KMS2_BASE}/api/v1/kme/verify\"\n    dec_url = f\"{KMS2_BASE}/api/v1/keys/dec_keys\"\n\n    for _ in range(10):\n        # Step 1: Request 2 encryption keys (size=256) from KMS-1\n        enc_payload = {\"number\": 2, \"size\": 256}\n        try:\n            enc_resp = requests.post(enc_url, headers=enc_headers_kms1, json=enc_payload, timeout=timeout)\n        except requests.exceptions.RequestException as e:\n            raise AssertionError(f\"KMS-1 encryption keys request failed: {e}\")\n        assert enc_resp.status_code == 200, f\"KMS-1 /enc_keys POST returned {enc_resp.status_code}\"\n        try:\n            enc_data = enc_resp.json()\n        except Exception:\n            raise AssertionError(\"KMS-1 /enc_keys response is not valid JSON\")\n        # Require keys or key_IDs to be present in response\n        assert (\"keys\" in enc_data and isinstance(enc_data[\"keys\"], list)) or (\"key_IDs\" in enc_data and isinstance(enc_data[\"key_IDs\"], list)), \"KMS-1 /enc_keys response missing keys or key_IDs list\"\n\n        # Extract key IDs for verification - try common key id fields\n        key_ids = None\n        if \"key_IDs\" in enc_data and isinstance(enc_data[\"key_IDs\"], list):\n            key_ids = enc_data[\"key_IDs\"]\n        elif \"keys\" in enc_data and isinstance(enc_data[\"keys\"], list):\n            # try to get id inside each key object\n            key_ids = []\n            for k in enc_data[\"keys\"]:\n                if isinstance(k, dict):\n                    for possible_id_key in [\"key_ID\", \"keyId\", \"id\", \"keyID\"]:\n                        if possible_id_key in k:\n                            key_ids.append(str(k[possible_id_key]))\n                            break\n                else:\n                    key_ids.append(str(k))\n        else:\n            key_ids = []\n            for v in enc_data.values():\n                if isinstance(v, list):\n                    key_ids.extend(str(i) for i in v)\n        if not key_ids or len(key_ids) < 2:\n            raise AssertionError(\"Less than 2 key IDs received from /enc_keys\")\n\n        # Step 2: Verify on KMS-2 that keys are all_verified=true\n        verify_payload = {\"key_IDs\": key_ids}\n        try:\n            verify_resp = requests.post(verify_url, headers=kme_verify_headers, json=verify_payload, timeout=timeout)\n        except requests.exceptions.RequestException as e:\n            raise AssertionError(f\"KMS-2 /kme/verify request failed (KMS-2 may be unreachable): {e}\")\n        assert verify_resp.status_code == 200, f\"KMS-2 /kme/verify returned {verify_resp.status_code}\"\n        try:\n            verify_data = verify_resp.json()\n        except Exception:\n            raise AssertionError(\"KMS-2 /kme/verify response is not valid JSON\")\n        all_verified = verify_data.get(\"all_verified\")\n        assert all_verified is True, f\"KMS-2 /kme/verify all_verified is not true (got {all_verified})\"\n\n        # Step 3: Request decryption keys for those key IDs from KMS-2 with swapped headers\n        dec_payload = {\"key_IDs\": key_ids}\n        try:\n            dec_resp = requests.post(dec_url, headers=dec_headers_kms2, json=dec_payload, timeout=timeout)\n        except requests.exceptions.RequestException as e:\n            raise AssertionError(f\"KMS-2 /dec_keys request failed: {e}\")\n        assert dec_resp.status_code == 200, f\"KMS-2 /dec_keys POST returned {dec_resp.status_code}\"\n        try:\n            dec_data = dec_resp.json()\n        except Exception:\n            raise AssertionError(\"KMS-2 /dec_keys response is not valid JSON\")\n\n        # We do not reuse keys so just confirm we get the requested keys back\n        dec_key_ids_resp = None\n        if \"keys\" in dec_data and isinstance(dec_data[\"keys\"], list):\n            dec_key_ids_resp = []\n            for k in dec_data[\"keys\"]:\n                if isinstance(k, dict):\n                    for possible_id_key in [\"key_ID\", \"keyId\", \"id\", \"keyID\"]:\n                        if possible_id_key in k:\n                            dec_key_ids_resp.append(str(k[possible_id_key]))\n                            break\n                else:\n                    dec_key_ids_resp.append(str(k))\n        elif \"key_IDs\" in dec_data and isinstance(dec_data[\"key_IDs\"], list):\n            dec_key_ids_resp = dec_data[\"key_IDs\"]\n        elif isinstance(dec_data, list):\n            dec_key_ids_resp = [str(k) for k in dec_data]\n\n        assert dec_key_ids_resp is not None, \"Did not find key IDs in decryption keys response\"\n        assert set(dec_key_ids_resp) == set(key_ids), \"Decryption keys returned do not match requested key IDs\"\n        # Small sleep to avoid socket buildup or rate limits\n        time.sleep(0.1)\n\n    # Step 4: Finally, call the KMS-2 /api/v1/kme/pool/replenish POST endpoint to trigger pool replenishment\n    try:\n        replenish_resp = requests.post(replenish_url, headers={\"Connection\": \"close\"}, timeout=timeout)\n    except requests.exceptions.RequestException as e:\n        raise AssertionError(f\"KMS-2 /kme/pool/replenish request failed: {e}\")\n    assert replenish_resp.status_code == 200, f\"/kme/pool/replenish returned {replenish_resp.status_code}\"\n\ntest_post_kme_pool_replenish()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 29, in test_post_kme_pool_replenish\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 118, in <module>\n  File \"<string>\", line 31, in test_post_kme_pool_replenish\nAssertionError: KMS-1 encryption keys request failed: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=5)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-01T16:37:50.593Z",
    "modified": "2025-11-01T16:39:52.693Z"
  }
]
