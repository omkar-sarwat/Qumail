[
  {
    "projectId": "e2265849-69ec-48c4-aafc-dd2b45da2ed7",
    "testId": "ae8cc7ca-e89b-4077-bca8-8ffb2c9966ac",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC001-health check endpoint returns complete service status",
    "description": "Verify that the /health GET endpoint returns a 200 status with a JSON object containing the health status of the database, km_server_1, km_server_2, security_auditor, version, timestamp, and uptime_seconds.",
    "code": "import requests\n\ndef test_health_check_endpoint_returns_complete_service_status():\n    base_url = \"http://localhost:8000\"\n    url = f\"{base_url}/health\"\n    timeout = 30\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    try:\n        response = requests.get(url, headers=headers, timeout=timeout)\n    except requests.RequestException as e:\n        assert False, f\"Request to /health endpoint failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate keys in response JSON\n    expected_keys = {\"healthy\", \"services\", \"version\", \"timestamp\", \"uptime_seconds\"}\n    assert expected_keys.issubset(data.keys()), f\"Response JSON missing keys from {expected_keys}\"\n\n    services = data.get(\"services\")\n    assert isinstance(services, dict), \"services should be a JSON object\"\n    expected_services = {\"database\", \"km_server_1\", \"km_server_2\", \"security_auditor\"}\n    assert expected_services.issubset(services.keys()), f\"services object missing keys: {expected_services}\"\n\n    # Validate types of each expected key\n    assert isinstance(data[\"healthy\"], bool), \"healthy should be a boolean\"\n    assert all(isinstance(services[srv], str) for srv in expected_services), \"All service statuses should be strings\"\n    assert isinstance(data[\"version\"], str), \"version should be a string\"\n    assert isinstance(data[\"timestamp\"], str), \"timestamp should be a string\"\n    assert isinstance(data[\"uptime_seconds\"], (int, float)), \"uptime_seconds should be a number\"\n\ntest_health_check_endpoint_returns_complete_service_status()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-18T07:11:52.131Z",
    "modified": "2025-10-18T07:12:10.767Z"
  },
  {
    "projectId": "e2265849-69ec-48c4-aafc-dd2b45da2ed7",
    "testId": "257da181-171f-40c3-9f5a-5b9b6a148e50",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC002-root endpoint provides api information and features",
    "description": "Verify that the / GET endpoint returns a 200 status with API information including service name, version, status, environment, documentation URL, supported security levels, features list, and timestamp.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_root_endpoint_provides_api_information_and_features():\n    url = f\"{BASE_URL}/\"\n    try:\n        response = requests.get(url, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to root endpoint failed: {e}\"\n    \n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    \n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n    \n    # Validate required fields existence and type\n    required_fields = {\n        \"service\": str,\n        \"version\": str,\n        \"status\": str,\n        \"environment\": str,\n        \"documentation\": str,\n        \"security_levels\": list,\n        \"features\": list,\n        \"timestamp\": str\n    }\n    \n    for field, expected_type in required_fields.items():\n        assert field in data, f\"Missing field '{field}' in response\"\n        assert isinstance(data[field], expected_type), f\"Field '{field}' is not of type {expected_type.__name__}\"\n    \n    # Validate security_levels and features list items type\n    assert all(isinstance(item, str) for item in data[\"security_levels\"]), \"All items in 'security_levels' must be strings\"\n    assert all(isinstance(item, str) for item in data[\"features\"]), \"All items in 'features' must be strings\"\n\ntest_root_endpoint_provides_api_information_and_features()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-18T07:11:52.136Z",
    "modified": "2025-10-18T07:12:12.161Z"
  },
  {
    "projectId": "e2265849-69ec-48c4-aafc-dd2b45da2ed7",
    "testId": "802c7340-da1c-4a95-8755-f1f8f5a6f724",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC003-get emails endpoint returns emails from specified folder",
    "description": "Verify that the /emails GET endpoint returns a 200 status with a list of emails from the specified folder (inbox or sent), including email metadata such as id, flow_id, sender, receiver, subject, timestamp, isRead, isStarred, securityLevel, direction, and isSuspicious. Also verify pagination with nextPageToken and totalCount.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_get_emails_from_specified_folder():\n    url = f\"{BASE_URL}/emails\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    params = {\n        \"folder\": \"inbox\",\n        \"maxResults\": 50\n    }\n\n    response = None\n    try:\n        response = requests.get(url, headers=headers, params=params, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n        data = response.json()\n\n        # Validate main response keys\n        assert isinstance(data, dict), \"Response JSON must be an object\"\n        assert \"emails\" in data, \"'emails' key missing in response\"\n        assert \"totalCount\" in data, \"'totalCount' key missing in response\"\n        assert \"nextPageToken\" in data, \"'nextPageToken' key missing in response\"\n        assert \"userEmail\" in data, \"'userEmail' key missing in response\"\n\n        emails = data[\"emails\"]\n        assert isinstance(emails, list), \"'emails' must be a list\"\n        total_count = data[\"totalCount\"]\n        assert isinstance(total_count, int), \"'totalCount' must be an integer\"\n        next_page_token = data[\"nextPageToken\"]\n        assert isinstance(next_page_token, (str, type(None))), \"'nextPageToken' must be string or null\"\n        user_email = data[\"userEmail\"]\n        assert isinstance(user_email, str), \"'userEmail' must be a string\"\n\n        # Validate each email metadata\n        expected_keys = {\n            \"id\": int,\n            \"flow_id\": str,\n            \"sender\": str,\n            \"receiver\": str,\n            \"subject\": str,\n            \"timestamp\": str,\n            \"isRead\": bool,\n            \"isStarred\": bool,\n            \"securityLevel\": int,\n            \"direction\": str,\n            \"isSuspicious\": bool\n        }\n        for email in emails:\n            assert isinstance(email, dict), \"Each email must be an object\"\n            for key, expected_type in expected_keys.items():\n                assert key in email, f\"Email is missing key '{key}'\"\n                value = email[key]\n                # Allow None for string fields if any edge cases\n                if expected_type == str:\n                    assert (value is None) or isinstance(value, str), f\"Email key '{key}' must be string or None\"\n                else:\n                    assert isinstance(value, expected_type), f\"Email key '{key}' must be of type {expected_type.__name__}\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_get_emails_from_specified_folder()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 65, in <module>\n  File \"<string>\", line 19, in test_get_emails_from_specified_folder\nAssertionError: Expected status code 200, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-18T07:11:52.141Z",
    "modified": "2025-10-18T07:12:25.168Z"
  },
  {
    "projectId": "e2265849-69ec-48c4-aafc-dd2b45da2ed7",
    "testId": "e4dd8597-aff2-4034-b4ab-8ecf4884f36d",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC004-send encrypted email with valid security level",
    "description": "Verify that the /emails/send POST endpoint successfully sends an email encrypted with the selected security level (1 to 4). The response should include success status, emailId, flowId, encryptionMethod, securityLevel, entropy, keyId, encryptedSize, timestamp, and a success message.",
    "code": "import requests\nimport random\nimport string\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# NOTE: Replace 'YOUR_ACCESS_TOKEN' with a valid OAuth 2.0 access token for the test environment\n\n\ndef test_send_encrypted_email_with_valid_security_level():\n    url = f\"{BASE_URL}/emails/send\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": \"Bearer YOUR_ACCESS_TOKEN\"\n    }\n    # Prepare a valid security level between 1 and 4\n    security_level = random.randint(1, 4)\n\n    # Generate random subject and body to avoid duplication and for uniqueness\n    random_str = ''.join(random.choices(string.ascii_letters + string.digits, k=8))\n    payload = {\n        \"subject\": f\"Test Email Subject {random_str}\",\n        \"body\": f\"This is the body of the test encrypted email at security level {security_level}.\",\n        \"recipient\": \"testrecipient@example.com\",\n        \"securityLevel\": security_level\n    }\n\n    try:\n        response = requests.post(url, headers=headers, json=payload, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to send encrypted email failed with exception: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        resp_json = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate success flag\n    assert \"success\" in resp_json, \"Response missing 'success' key\"\n    assert resp_json[\"success\"] is True, \"Email sending not successful\"\n\n    # Validate required fields presence and types\n    expected_fields = {\n        \"emailId\": int,\n        \"flowId\": str,\n        \"encryptionMethod\": str,\n        \"securityLevel\": int,\n        \"entropy\": (float, int),\n        \"keyId\": str,\n        \"encryptedSize\": int,\n        \"timestamp\": str,\n        \"message\": str,\n    }\n    for field, ftype in expected_fields.items():\n        assert field in resp_json, f\"Response missing '{field}' key\"\n        assert isinstance(resp_json[field], ftype), f\"Field '{field}' expected type {ftype} but got type {type(resp_json[field])}\"\n\n    # Validate that the returned securityLevel matches the requested one\n    assert resp_json[\"securityLevel\"] == security_level, (\n        f\"Returned securityLevel {resp_json['securityLevel']} does not match requested {security_level}\"\n    )\n\ntest_send_encrypted_email_with_valid_security_level()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 66, in <module>\n  File \"<string>\", line 34, in test_send_encrypted_email_with_valid_security_level\nAssertionError: Expected status code 200, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-18T07:11:52.146Z",
    "modified": "2025-10-18T07:12:39.675Z"
  },
  {
    "projectId": "e2265849-69ec-48c4-aafc-dd2b45da2ed7",
    "testId": "6839e387-d15c-42a9-9db4-f0f7e079ed52",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC005-encryption status endpoint returns real time quantum key metrics",
    "description": "Verify that the /encryption/status GET endpoint returns a 200 status with detailed encryption status including kmeStatus array, quantumKeysAvailable count, encryptionStats for each encryption type, entropyStatus, averageEntropy, keyUsage array, securityLevels object, timestamp, and overall systemStatus.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_encryption_status_endpoint_returns_real_time_quantum_key_metrics():\n    url = f\"{BASE_URL}/encryption/status\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n\n    resp_json = response.json()\n\n    # Validate top-level keys presence\n    expected_keys = [\n        \"kmeStatus\",\n        \"quantumKeysAvailable\",\n        \"encryptionStats\",\n        \"entropyStatus\",\n        \"averageEntropy\",\n        \"keyUsage\",\n        \"securityLevels\",\n        \"timestamp\",\n        \"systemStatus\"\n    ]\n    for key in expected_keys:\n        assert key in resp_json, f\"Response JSON missing expected key: {key}\"\n\n    # Validate kmeStatus is a non-empty list of dicts with required fields\n    kme_status_list = resp_json[\"kmeStatus\"]\n    assert isinstance(kme_status_list, list), \"kmeStatus should be a list\"\n    assert len(kme_status_list) > 0, \"kmeStatus list should not be empty\"\n    kme_required_keys = {\"id\", \"name\", \"status\", \"latency\", \"keysAvailable\", \"maxKeySize\", \"averageEntropy\", \"keyGenRate\", \"zone\"}\n    for kme in kme_status_list:\n        assert isinstance(kme, dict), \"Each kmeStatus item should be a dict\"\n        missing = kme_required_keys - kme.keys()\n        assert not missing, f\"kmeStatus item missing keys: {missing}\"\n        # Validate field types\n        assert isinstance(kme[\"id\"], str)\n        assert isinstance(kme[\"name\"], str)\n        assert isinstance(kme[\"status\"], str)\n        assert isinstance(kme[\"latency\"], (int, float))\n        assert isinstance(kme[\"keysAvailable\"], int)\n        assert isinstance(kme[\"maxKeySize\"], int)\n        assert isinstance(kme[\"averageEntropy\"], (int, float))\n        assert isinstance(kme[\"keyGenRate\"], (int, float))\n        assert isinstance(kme[\"zone\"], str)\n\n    # Validate quantumKeysAvailable is int >= 0\n    assert isinstance(resp_json[\"quantumKeysAvailable\"], int)\n    assert resp_json[\"quantumKeysAvailable\"] >= 0\n\n    # Validate encryptionStats fields with int values\n    encryption_stats = resp_json[\"encryptionStats\"]\n    assert isinstance(encryption_stats, dict)\n    expected_enc_stats_keys = {\"quantum_otp\", \"quantum_aes\", \"post_quantum\", \"standard_rsa\"}\n    missing_enc_keys = expected_enc_stats_keys - encryption_stats.keys()\n    assert not missing_enc_keys, f\"encryptionStats missing keys: {missing_enc_keys}\"\n    for key in expected_enc_stats_keys:\n        assert isinstance(encryption_stats[key], int)\n        assert encryption_stats[key] >= 0\n\n    # Validate entropyStatus is a string\n    assert isinstance(resp_json[\"entropyStatus\"], str)\n\n    # Validate averageEntropy is a number (int or float)\n    assert isinstance(resp_json[\"averageEntropy\"], (int, float))\n\n    # Validate keyUsage is an array (content unspecified)\n    assert isinstance(resp_json[\"keyUsage\"], list)\n\n    # Validate securityLevels is an object (dict)\n    assert isinstance(resp_json[\"securityLevels\"], dict)\n\n    # Validate timestamp is a string (ISO8601 or similar)\n    assert isinstance(resp_json[\"timestamp\"], str)\n    assert len(resp_json[\"timestamp\"]) > 0\n\n    # Validate systemStatus is a string\n    assert isinstance(resp_json[\"systemStatus\"], str)\n\ntest_encryption_status_endpoint_returns_real_time_quantum_key_metrics()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-18T07:11:52.151Z",
    "modified": "2025-10-18T07:12:13.569Z"
  },
  {
    "projectId": "e2265849-69ec-48c4-aafc-dd2b45da2ed7",
    "testId": "c89dd97c-c3ba-46f1-8df4-8f0c008b2495",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC006-generate quantum keys endpoint creates keys on both kmes",
    "description": "Verify that the /api/v1/quantum/generate-keys POST endpoint generates the requested number of quantum keys on both KME1 and KME2, returning success status, counts of generated, successful, failed keys, success rates for each KME and total, keyTimestamps array, and generatedAt timestamp.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_generate_quantum_keys_endpoint_creates_keys_on_both_kmes():\n    url = f\"{BASE_URL}/api/v1/quantum/generate-keys\"\n    requested_count = 15\n    params = {\"count\": requested_count}\n    headers = {\n        \"Accept\": \"application/json\",\n        # Assuming OAuth 2.0 Bearer token is required; replace with valid token if needed\n        # \"Authorization\": \"Bearer YOUR_ACCESS_TOKEN_HERE\"\n    }\n\n    try:\n        response = requests.post(url, params=params, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        raise AssertionError(f\"Request failed: {e}\")\n\n    json_resp = response.json()\n\n    # Assert top-level keys present\n    expected_keys = {\n        \"success\",\n        \"requestedKeys\",\n        \"kme1\",\n        \"kme2\",\n        \"total\",\n        \"keyTimestamps\",\n        \"generatedAt\",\n    }\n    assert expected_keys.issubset(json_resp.keys()), \"Missing keys in response\"\n\n    # Validate success and requestedKeys\n    assert isinstance(json_resp[\"success\"], bool), \"success must be boolean\"\n    assert json_resp[\"success\"] is True, \"success must be True\"\n\n    assert isinstance(json_resp[\"requestedKeys\"], int), \"requestedKeys must be int\"\n    assert json_resp[\"requestedKeys\"] == requested_count, \"requestedKeys mismatch\"\n\n    # Helper to validate KME stats object\n    def validate_kme_stats(kme_obj):\n        required = {\"generated\", \"successful\", \"failedKeys\", \"successRate\"}\n        assert required.issubset(kme_obj.keys()), f\"Missing keys in KME stats: {required - kme_obj.keys()}\"\n\n        assert isinstance(kme_obj[\"generated\"], int), \"generated must be int\"\n        assert isinstance(kme_obj[\"successful\"], int), \"successful must be int\"\n        assert isinstance(kme_obj[\"failedKeys\"], int), \"failedKeys must be int\"\n        assert 0.0 <= kme_obj[\"successRate\"] <= 1.0, \"successRate must be between 0 and 1\"\n\n        # Logical consistency checks\n        assert kme_obj[\"generated\"] >= 0\n        assert kme_obj[\"successful\"] >= 0\n        assert kme_obj[\"failedKeys\"] >= 0\n        assert kme_obj[\"generated\"] == kme_obj[\"successful\"] + kme_obj[\"failedKeys\"], \"generated != successful + failedKeys\"\n\n    # Validate KME1 and KME2 stats\n    validate_kme_stats(json_resp[\"kme1\"])\n    validate_kme_stats(json_resp[\"kme2\"])\n    validate_kme_stats(json_resp[\"total\"])\n\n    # Validate total counts consistency\n    total = json_resp[\"total\"]\n    kme1 = json_resp[\"kme1\"]\n    kme2 = json_resp[\"kme2\"]\n\n    assert total[\"generated\"] == kme1[\"generated\"] + kme2[\"generated\"], \"Total generated mismatch\"\n    assert total[\"successful\"] == kme1[\"successful\"] + kme2[\"successful\"], \"Total successful mismatch\"\n    assert total[\"failedKeys\"] == kme1[\"failedKeys\"] + kme2[\"failedKeys\"], \"Total failedKeys mismatch\"\n\n    # Validate keyTimestamps is list of strings (ISO8601 or similar)\n    key_timestamps = json_resp[\"keyTimestamps\"]\n    assert isinstance(key_timestamps, list), \"keyTimestamps must be a list\"\n    assert all(isinstance(ts, str) and ts for ts in key_timestamps), \"All keyTimestamps must be non-empty strings\"\n    assert len(key_timestamps) >= 0\n\n    # Validate generatedAt is a non-empty string (timestamp)\n    generated_at = json_resp[\"generatedAt\"]\n    assert isinstance(generated_at, str) and generated_at, \"generatedAt must be a non-empty string\"\n\ntest_generate_quantum_keys_endpoint_creates_keys_on_both_kmes()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-18T07:11:52.156Z",
    "modified": "2025-10-18T07:12:21.812Z"
  },
  {
    "projectId": "e2265849-69ec-48c4-aafc-dd2b45da2ed7",
    "testId": "5575091a-7061-40f9-b5ac-2bc13a314518",
    "userId": "d41894b8-3061-700b-028c-5c6b57a52107",
    "title": "TC007-quantum status dashboard redirects to static html page",
    "description": "Verify that the /quantum/status GET endpoint responds with a 307 redirect to the static quantum status dashboard HTML page.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\n\n\ndef test_tc007_quantum_status_dashboard_redirect():\n    url = f\"{BASE_URL}/quantum/status\"\n    try:\n        response = requests.get(url, timeout=30, allow_redirects=False)\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed with exception: {e}\"\n\n    # Assert response status code is 307 Temporary Redirect\n    assert response.status_code == 307, (\n        f\"Expected status code 307 for redirect but got {response.status_code}\"\n    )\n\n    # The Location header should be present and point to the static HTML page\n    location = response.headers.get(\"location\") or response.headers.get(\"Location\")\n    assert location is not None, \"Redirect response missing Location header\"\n\n    # Check that the redirect location ends with 'quantum_status.html'\n    assert location.endswith(\"quantum_status.html\"), (\n        f\"Redirect location expected to end with 'quantum_status.html' but got: {location}\"\n    )\n\n\ntest_tc007_quantum_status_dashboard_redirect()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 28, in <module>\n  File \"<string>\", line 14, in test_tc007_quantum_status_dashboard_redirect\nAssertionError: Expected status code 307 for redirect but got 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-18T07:11:52.161Z",
    "modified": "2025-10-18T07:12:24.708Z"
  }
]
